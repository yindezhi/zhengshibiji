<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    /* 
    调用Generator  函数后，该函数并不执行，返回的也不是函数运行结果，而是一个**指向内部状态**的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）

    总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。一开始函数是不会执行的，因为他是个状态对象

    如何让这个Generator函数执行呢？
    每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。
    {value:xx,done:false}

    value属性表示当前的内部状态的值，是yield或者return表达式后面那个表达式的值；
    done属性是一个布尔值，表示是否遍历结束。
    false代表没有结束，true代表结束了
     */
    //  function* fn(){
    //      console.log(1);
    //      yield 'hello';
    //      console.log(2);
    //      return 5;
    //  }
    //  let f = fn();
    //  console.log(f.next());
    //  console.log(f.next());
    //  console.log(f.next());
     
        // function* gen(){
        //     yield 2 + 1;
        // }
        // console.log(gen().next().value);

            // function* fn(){
            //     //同步编程函数，这个函数就算有异步也算同步
            //     console.log(1);
            //     let a = yield;
            //     //异步的数据已经到手；
            //     console.log(a);
            //     console.log(2);
            // }

            // let f = fn();
            // f.next();
            // setTimeout(() =>{
            //     f.next('异步的数据已经到手');
            // },1000);

            // function* foo(x){
            //     var y = 2 * (yield(x + 1));
            //     var z = yield y;
            //     return (x + y + z);
            // }

            // var a = foo(5);//遍历对象

            // a.next();//{value:6,done:false}
                // a.next(12);//这次next的参数，就是上次yield的返回值
                // console.log(a.next(12));
                
                // function* fnn(){
            //     yield '1';
            //     yield '2';
            // }

            // function* ff(){
            //     yield* fnn();
            //     yield '3';
            // }

            // for(let i of ff()){
            //     console.log(i);
            // }

            // let a = (function* (){
            //     yield '1'
            // })();
            // console.log(a.next().value);


            // function* f(g1,g2){
            //     yield* g2(); 
            //     yield* g1();
            // }

            // let ff = f(function* a(){
            //     yield 1;
            // },function* b(){
            //     yield 2;
            // });

            // // console.log(ff);
            // for(let i of ff){
            //     console.log(i);
            // }


            
            // function* aa(){
            //     console.log(this);
            //     // this.a = 11;
            // }

            // let obj = {}
            // let a = aa();//aa.call(obj);
            // a.next();
            // console.log( obj.a );
                
                
        
     
     
</script>
</body>
</html>