##  同步异步

> JS按理来说是从上往下解读代码，它是单线程的（同一时间只能做一件事情）

> js单线程从上往下解读代码会走事件调用

- 事件调用 => 把任务交给了事件引擎（所有的js事件都是异步的）
- 事件堆列 => 时间任务放到堆列里
- 事件循环 => 当主线程空闲的时候执行压入的代码,执行完后再从异步队列中压入异步代码到主线程中的过程叫事件循环

>  同步：
    代码从上往下依次执行，如果一个地方卡住了，下面的代码就不执行了。
  异步：
    虽然从上往下执行，如果一个地方卡住了，不阻止代码向下执行，promise

  定时器、所有事件、promise

  异步队列分为宏任务和微任务

  promise是个异步，微任务，是解决异步编程问题的，也就是说让异步的代码同步执行

> 代码有可能会报错的情况下，防止该代码报错，使用     try，catch包一下就不会阻止错误代码下面的代码运行了
            try{}catch(e){}

  异步的操作是不容易进行维护开发的，同步操作才利于维护开发（上面的代码执行完才会执行下面的，有序的）
  如果用回调函数的方式去解决，那么会出现回调地狱
  从上往下的阅读方式，方便开发人员调试和判断

  主线程 -> 异步队列
                ↓ 
            微任务(promise为微任务)
                ↓
            宏任务 (定时器)
  不按绑定顺序变化

  promise是解决异步编程顺序问题的（也就是说，让异步的代码同步执行）

  主线程     异步队列
  先执行     然后异步队列的进入主线程最下面
  分为 微任务  宏任务(根据任务是否成立压到主线程里)

>   顺序
        先执行主线程的代码. 
        主线程中有异步代码(定时器,promise或者事件),会把异步代码放到异步队列中,条件成立时,再把异步代码压入主线程中执行
        有微任务先执行微任务,执行完后执行宏任务
        如果宏任务中还有微任务,先执行宏任务,再执行宏任务中的微任务

>   事件循环
        当主线程空闲的时候执行压入的代码,执行完之后再从异步队列中压入异步代码到主线程中的过程叫事件循环
-   先执行主线程的代码

-   主线程中有异步代码(定时器,promise或者事件)时,会把异步代码放到异步队列中,条件成立时,早把异步代码压入主线程中执行

-   有微任务先执行微任务,执行完后执行宏任务

-   如果宏任务中还有微任务,先执行宏任务,再执行宏任务中的微任务

###  promise

>  promise -> 承诺

>  介绍下promise：
-  是异步编程的一种解决方法,代码有同步编程、异步编程, 同步编程是...(),异步编程是...()
-  这就牵扯到了异步队列和主线程,代码执行时,会先执行主线程的代码...()
-  是es6 的一个语法,内部有三个状态:pending(进行中)、fulfiled(已成功)、rejected(已失败), 状态改变只能进行一次,然后就状态就会冻结在这个状态,只能是从pendig->fulfiled或者pending->rejected,
-  promise会返回一个对象,对象会加状态pending,resolved,rejected ,失败进catch(状态rejected),成功进then(resolved), finally 是不管层高还是失败都会进的回调函数
> promise.all
```js
  将多个Promise实例，包装成一个新的Promise实例 数组中的异步操作都要成功才返回成功结果 只要有一个进入reject p的状态就变成了reject

  const p = Promise.all([p1],[p2],[p3])

```
> promise.race
```js
  将多个Promise实例，包装成一个新的Promise实例 在数组中只要有一个异步成功就返回这次成功的结果，

  let p = Promise.race([myFetch('2.json'),myFetch('1.json')])

```
>　promise.resolve
```js
  现有对象转换成promise对象需要用到promise.resolve

  promise.resole('foo')
        ⬇
  new Promise(resolve => resolve('foo'))

```

> promise.prototype.finally()
```js
 finally 方法 用于 指定不管Promise对象最后状态如何，都会执行的操作

promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});

```

promise 中的 .then

- then方法里有两个参数,一个成功resolve,一个reject
- .then里,再return也不会报错,相当于return了一个{}
- trow 是抛出异常 说明代码错误 进catch
- .then 和 .catch 的返回结果没有返回值时,返回结果undefined
- .then 和 .catch 的返回值不能是promise本身, 要不会造成死循环
- promise resolve 的值会穿透
- .then()中只能插函数 不是函数就穿透,穿透到下一项函数,没有的话直接穿透数字
如果是函数,最后log接收的是最后一个函数的返回值

> promise的结构
```js
let p = new Promise(function(resove,reject){
    resolve()
});
p.then(function(data)){
    console.log(data)
}


new Promise(function(resolve,reject){
    //主线程
    // 异步代码执行完,通过异步代码的结果去调用resolve或者reject
    // 异步代码有可能报错或者错误,如果报错或者错误就执行reject
    // 一般都是resolve(放异步的结果)
    resolve()
});
//他有一个返回值,返回值是promise对象,这个对象有then方法

// .then() 中只能查函数 不是会穿透
// 第一个then的返回值,是第二个then 的参数
then(成功函数,失败函数)   // then中包含两个函数 (成功后的回调,失败后的可以不用写,直接在.then函数之后.catch就可以)
// 第一个then
//      成功函数里面的参数就是异步的结果
// 第二个then
//      第一个then 的返回值

// 如果代码有可能会报错,下面的代码是不会执行的,如果私用try,catch
// 那么try中的代码报错会进catch,报错是不会影响后面代码执行的

try{

}catch(){

}

```

解决异步编程问题, 同步是(),异步是(),
    牵扯到了异步队列 和主线程微任务宏任务
    是es6的一个语法,内部有三个状态(pendingfulfiled或rejected),状态改变只能一次,能是从pending->fulfiled或pending->rejected

    promise会返回一个对象,对象会加状态(pending,resolved,rejected)
        失败进catch 成功进then 

    then方法有两个参数,一个成功resolve一个失败reject,

    .then里  再return 不会报错 相当于return了一个{} 
    throw 是抛出异常   说明代码错误  进catch 

    .then后的返回结果美誉返回值时,返回结果undefind

    .then和.chatch 的返回值不能是promise本身,要不会造成死循环

    promise resolve的值会穿透

    promise解决了异步编程的问题
    在then里面就走“同步”

    resolve: 正确
    reject： 错误

```js

new Promise(function(resolve,reject){
            resolve(5)
        };
        p.then(function(data){
            console.log(data)
        })
        then中的才为promise的微任务 ,then中为同步
        .then(console.log)
        .then()中只能插函数    不是函数就穿透 穿透到下一项函数 如果没有直接->变量数字
        如果是函数  最后log接受的是最后一个函数的返回值 
        失败成功只执行一次, 执行后状态无法改变 ,
        一旦 成功resolve 就不会进catch
        // try catch (失败 报失败) 确保报错时可以从catch执行reject
        try{
        }catch(e){
            reject(e)
        }

```

```js
new Promise(function(resolve,reject){
    //主线程
    //当异步代码执行完，通过异步代码的结果去调用resolve或者reject

    // 异步代码有可能报错或者错误，如果报错或者错误就执行reject

    //一般都是resolve（放异步的结果）
})

它有一个返回值，返回值是promise对象，这个对象有then方法
then中包括两个函数（成功函数，失败函数）

json => 长的像对象和数组的字符串, 本质是字符串
    json 转 对象    JSON.parse()        // parse必须为标准格式的json格式   '{"":""}'   才能成功转化
    对象 转 json    json.stringify()   //副作用是 函数和undefined 的会被过滤掉

第一个then（微任务）
    成功函数里面的参数就是异步的结果
第二个then（微任务）
    第一个then的返回值

    切记***此时的知识点需要后期内容的铺垫和若干个异步请求实验总结才能领悟这个promise

```

>    虽然promise解决了异步编程的问题，但是在then的外面还是异步的

>    没有promise也能开发，只不过就是维护起来麻烦点

>    then中包含了2个函数，第一个函数是成功之后的回调，第二个函数是失败之后的回调

>    finally:不管成功还是失败都会进的回调函数

>    如果代码有可能会报错，下面的代码是不会执行的，如果，如果使用try，catch
     那么try中的代码报错会进catch，报错是不会影响后面代码执行的
```js
    try{

    }catch(e){

    }

    //第一个then的返回值，是第二then的参数

    fetch().then(function(d){
        return d.json();
    }).then(function(d){
        console.log(d);//d就是d.json()
    });

    当进第一个then的时候，d就是返回的数据，但是这个数据是被promise包了一层
    d.json() ->'[]' ->[]

    JSON -> 长的像对象和数组的字符串，本质是字符串

    '[]'JSON -> []数组
    '{}'JSON -> {}对象

    JSON取值是不方便的，可以使用JSON.parse(),把JSON转成对象

    parse必须为标准的JSON格式才成功转换
    '{"name":"zf"}'
    '[]' -> []

    对象转JSON -> JSON.stringify()的副作用是函数和undefined会被过滤掉
    [] -> '[]'/ 

```
```js

 then里面才是微任务
 cons promise = new Promise((resolve,reject)=>{
     console.log(1);//主线程
     resolve（）；
     console.log(2);//主线程
 })
 promise.then(()=>{
     console.log(3);//微任务
 })
 console.log(4);//主线程

```
